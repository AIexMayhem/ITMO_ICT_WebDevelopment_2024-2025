{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 1 1) \u0421\u0434\u0435\u043b\u0430\u043d\u044b \u0431\u0430\u0437\u043e\u0432\u044b\u0435 UDP \u0438 TCP \u043a\u043b\u0438\u0435\u043d\u0442-\u0441\u0435\u0440\u0432\u0435\u0440\u043d\u044b\u0435 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f 2) \u0421\u0434\u0435\u043b\u0430\u043d \u0431\u0430\u0437\u043e\u0432\u044b\u0439 Web-\u0441\u0435\u0440\u0432\u0435\u0440 3) \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 TCP \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b 4) \u041d\u0430\u043f\u0438\u0441\u0430\u043d Web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441\u043e \u0448\u043a\u043e\u043b\u044c\u043d\u044b\u043c\u0438 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 2 \u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0442\u0435\u043b\u0435\u0439 \u2003\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u0435\u043b\u044f, \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430 \u043e\u0442\u0435\u043b\u044f, \u0430\u0434\u0440\u0435\u0441, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435, \u0442\u0438\u043f\u044b \u043d\u043e\u043c\u0435\u0440\u043e\u0432, \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c, \u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u044c, \u0443\u0434\u043e\u0431\u0441\u0442\u0432\u0430. \u2003\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b: \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u043d\u043e\u0432\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439. \u041f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u0438 \u0440\u0435\u0437\u0435\u0440\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u043e\u043c\u0435\u0440\u043e\u0432. \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0441\u0432\u043e\u0438\u0445 \u0440\u0435\u0437\u0435\u0440\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0439. \u041d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043e\u0442\u0437\u044b\u0432\u043e\u0432 \u043a \u043d\u043e\u043c\u0435\u0440\u0430\u043c. \u041f\u0440\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0438 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0435\u0432, \u0434\u043e\u043b\u0436\u043d\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c\u0441\u044f \u043f\u0435\u0440\u0438\u043e\u0434 \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f, \u0442\u0435\u043a\u0441\u0442 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f, \u0440\u0435\u0439\u0442\u0438\u043d\u0433 (1-10), \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0442\u043e\u0440\u0435. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0437\u0430\u0441\u0435\u043b\u0438\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u043e\u0442\u0435\u043b\u044c \u0438 \u0432\u044b\u0441\u0435\u043b\u0438\u0442\u044c \u0438\u0437 \u043e\u0442\u0435\u043b\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Django-admin. \u0412 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u043e\u0439 \u0447\u0430\u0441\u0442\u0438 \u0434\u043e\u043b\u0436\u043d\u0430 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0430, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0449\u0430\u044f \u043f\u043e\u0441\u0442\u043e\u044f\u043b\u044c\u0446\u0435\u0432 \u043e\u0442\u0435\u043b\u044f \u0437\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u043c\u0435\u0441\u044f\u0446. \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 3 \u041e\u0442\u0435\u043b\u044c \u2003\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443, \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b. \u2003\u0422\u0430\u043a\u0430\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0442\u044c \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u0439 \u043e\u0431 \u0438\u043c\u0435\u044e\u0449\u0438\u0445\u0441\u044f \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u043d\u043e\u043c\u0435\u0440\u0430\u0445, \u043e \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u044e\u0449\u0438\u0445 \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\u0445 \u0438 \u043e \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445, \u0443\u0431\u0438\u0440\u0430\u044e\u0449\u0438\u0445\u0441\u044f \u0432 \u043d\u043e\u043c\u0435\u0440\u0430\u0445. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u043e\u043c\u0435\u0440\u043e\u0432 \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e, \u0438 \u0438\u043c\u0435\u044e\u0442\u0441\u044f \u043d\u043e\u043c\u0435\u0440\u0430 \u0442\u0440\u0435\u0445 \u0442\u0438\u043f\u043e\u0432: \u043e\u0434\u043d\u043e\u043c\u0435\u0441\u0442\u043d\u044b\u0439, \u0434\u0432\u0443\u0445\u043c\u0435\u0441\u0442\u043d\u044b\u0439 \u0438 \u0442\u0440\u0435\u0445\u043c\u0435\u0441\u0442\u043d\u044b\u0439, \u043e\u0442\u043b\u0438\u0447\u0430\u044e\u0449\u0438\u0435\u0441\u044f \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c\u044e \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u0432 \u0441\u0443\u0442\u043a\u0438. \u0412 \u043a\u0430\u0436\u0434\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435 \u0435\u0441\u0442\u044c \u0442\u0435\u043b\u0435\u0444\u043e\u043d. \u2003\u041e \u043a\u0430\u0436\u0434\u043e\u043c \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u044e\u0449\u0435\u043c \u0434\u043e\u043b\u0436\u043d\u0430 \u0445\u0440\u0430\u043d\u0438\u0442\u044c\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f: \u043d\u043e\u043c\u0435\u0440 \u043f\u0430\u0441\u043f\u043e\u0440\u0442\u0430, \u0444\u0430\u043c\u0438\u043b\u0438\u044f, \u0438\u043c\u044f, \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u043e, \u0433\u043e\u0440\u043e\u0434, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043e\u043d \u043f\u0440\u0438\u0431\u044b\u043b, \u0434\u0430\u0442\u0430 \u043f\u043e\u0441\u0435\u043b\u0435\u043d\u0438\u044f \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0447\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440. \u2003\u041e \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u0430 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f: \u0444\u0430\u043c\u0438\u043b\u0438\u044f, \u0438\u043c\u044f, \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u043e, \u0433\u0434\u0435 (\u044d\u0442\u0430\u0436) \u0438 \u043a\u043e\u0433\u0434\u0430 (\u0434\u0435\u043d\u044c \u043d\u0435\u0434\u0435\u043b\u0438) \u043e\u043d \u0443\u0431\u0438\u0440\u0430\u0435\u0442. \u0421\u043b\u0443\u0436\u0430\u0449\u0438\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0443\u0431\u0438\u0440\u0430\u0435\u0442 \u0432\u0441\u0435 \u043d\u043e\u043c\u0435\u0440\u0430 \u043d\u0430 \u043e\u0434\u043d\u043e\u043c \u044d\u0442\u0430\u0436\u0435 \u0432 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0435 \u0434\u043d\u0438 \u043d\u0435\u0434\u0435\u043b\u0438, \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u0432 \u0440\u0430\u0437\u043d\u044b\u0435 \u0434\u043d\u0438 \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u0443\u0431\u0438\u0440\u0430\u0442\u044c \u0440\u0430\u0437\u043d\u044b\u0435 \u044d\u0442\u0430\u0436\u0438. \u2003\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438: \u043e \u043a\u043b\u0438\u0435\u043d\u0442\u0430\u0445, \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u0432\u0448\u0438\u0445 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435, \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432\u0440\u0435\u043c\u0435\u043d\u0438; \u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432, \u043f\u0440\u0438\u0431\u044b\u0432\u0448\u0438\u0445 \u0438\u0437 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0433\u043e\u0440\u043e\u0434\u0430, \u043e \u0442\u043e\u043c, \u043a\u0442\u043e \u0438\u0437 \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445 \u0443\u0431\u0438\u0440\u0430\u043b \u043d\u043e\u043c\u0435\u0440 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u0434\u0435\u043d\u044c \u043d\u0435\u0434\u0435\u043b\u0438, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0445 \u043d\u043e\u043c\u0435\u0440\u043e\u0432; \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u043c\u0435\u0441\u0442\u0430 \u0436\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043b\u0438 \u0432 \u0442\u0435 \u0436\u0435 \u0434\u043d\u0438, \u0447\u0442\u043e \u0438 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043a\u043b\u0438\u0435\u043d\u0442, \u0432 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u2003\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u043d\u0430 \u0440\u0430\u0431\u043e\u0442\u0443 \u0438\u043b\u0438 \u0443\u0432\u043e\u043b\u0438\u0442\u044c \u0441\u043b\u0443\u0436\u0430\u0449\u0435\u0433\u043e \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b; \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043b\u0443\u0436\u0430\u0449\u0435\u0433\u043e; \u043f\u043e\u0441\u0435\u043b\u0438\u0442\u044c \u0438\u043b\u0438 \u0432\u044b\u0441\u0435\u043b\u0438\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u2003\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0440\u0435\u0434\u0443\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0442\u0430\u043a\u0436\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0432\u044b\u0434\u0430\u0447\u0438 \u043e\u0442\u0447\u0435\u0442\u0430 \u043e \u0440\u0430\u0431\u043e\u0442\u0435 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0437\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u043a\u0432\u0430\u0440\u0442\u0430\u043b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0433\u043e\u0434\u0430. \u0422\u0430\u043a\u043e\u0439 \u043e\u0442\u0447\u0435\u0442 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f: \u0447\u0438\u0441\u043b\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 \u0437\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432 \u043a\u0430\u0436\u0434\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435; \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u043e\u043c\u0435\u0440\u043e\u0432 \u043d\u0435 \u043a\u0430\u0436\u0434\u043e\u043c \u044d\u0442\u0430\u0436\u0435; \u043e\u0431\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u0434\u043e\u0445\u043e\u0434\u0430 \u0437\u0430 \u043a\u0430\u0436\u0434\u044b\u0439 \u043d\u043e\u043c\u0435\u0440; \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u044b\u0439 \u0434\u043e\u0445\u043e\u0434 \u043f\u043e \u0432\u0441\u0435\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435.","title":"\u0413\u043b\u0430\u0432\u043d\u0430\u044f"},{"location":"#web-","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443:  Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435"},{"location":"#1","text":"1) \u0421\u0434\u0435\u043b\u0430\u043d\u044b \u0431\u0430\u0437\u043e\u0432\u044b\u0435 UDP \u0438 TCP \u043a\u043b\u0438\u0435\u043d\u0442-\u0441\u0435\u0440\u0432\u0435\u0440\u043d\u044b\u0435 \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f 2) \u0421\u0434\u0435\u043b\u0430\u043d \u0431\u0430\u0437\u043e\u0432\u044b\u0439 Web-\u0441\u0435\u0440\u0432\u0435\u0440 3) \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 TCP \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b 4) \u041d\u0430\u043f\u0438\u0441\u0430\u043d Web-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441\u043e \u0448\u043a\u043e\u043b\u044c\u043d\u044b\u043c\u0438 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 1"},{"location":"#2","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 2"},{"location":"#_1","text":"\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0443\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043e\u0442\u0435\u043b\u044f, \u0432\u043b\u0430\u0434\u0435\u043b\u044c\u0446\u0430 \u043e\u0442\u0435\u043b\u044f, \u0430\u0434\u0440\u0435\u0441, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435, \u0442\u0438\u043f\u044b \u043d\u043e\u043c\u0435\u0440\u043e\u0432, \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c, \u0432\u043c\u0435\u0441\u0442\u0438\u043c\u043e\u0441\u0442\u044c, \u0443\u0434\u043e\u0431\u0441\u0442\u0432\u0430. \u2003\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b: \u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u044f \u043d\u043e\u0432\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439. \u041f\u0440\u043e\u0441\u043c\u043e\u0442\u0440 \u0438 \u0440\u0435\u0437\u0435\u0440\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u043e\u043c\u0435\u0440\u043e\u0432. \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0441\u0432\u043e\u0438\u0445 \u0440\u0435\u0437\u0435\u0440\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0439. \u041d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043e\u0442\u0437\u044b\u0432\u043e\u0432 \u043a \u043d\u043e\u043c\u0435\u0440\u0430\u043c. \u041f\u0440\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0438 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0435\u0432, \u0434\u043e\u043b\u0436\u043d\u044b \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0442\u044c\u0441\u044f \u043f\u0435\u0440\u0438\u043e\u0434 \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f, \u0442\u0435\u043a\u0441\u0442 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f, \u0440\u0435\u0439\u0442\u0438\u043d\u0433 (1-10), \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u043e \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0442\u043e\u0440\u0435. \u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0437\u0430\u0441\u0435\u043b\u0438\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u043e\u0442\u0435\u043b\u044c \u0438 \u0432\u044b\u0441\u0435\u043b\u0438\u0442\u044c \u0438\u0437 \u043e\u0442\u0435\u043b\u044f \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430\u043c\u0438 Django-admin. \u0412 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u043e\u0439 \u0447\u0430\u0441\u0442\u0438 \u0434\u043e\u043b\u0436\u043d\u0430 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u0430, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0449\u0430\u044f \u043f\u043e\u0441\u0442\u043e\u044f\u043b\u044c\u0446\u0435\u0432 \u043e\u0442\u0435\u043b\u044f \u0437\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u043c\u0435\u0441\u044f\u0446.","title":"\u0421\u043f\u0438\u0441\u043e\u043a \u043e\u0442\u0435\u043b\u0435\u0439"},{"location":"#3","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 3"},{"location":"#_2","text":"\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u0443\u044e \u0441\u0438\u0441\u0442\u0435\u043c\u0443, \u043f\u0440\u0435\u0434\u043d\u0430\u0437\u043d\u0430\u0447\u0435\u043d\u043d\u0443\u044e \u0434\u043b\u044f \u0430\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u0430 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b. \u2003\u0422\u0430\u043a\u0430\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u0442\u044c \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u0439 \u043e\u0431 \u0438\u043c\u0435\u044e\u0449\u0438\u0445\u0441\u044f \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u043d\u043e\u043c\u0435\u0440\u0430\u0445, \u043e \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u044e\u0449\u0438\u0445 \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\u0445 \u0438 \u043e \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445, \u0443\u0431\u0438\u0440\u0430\u044e\u0449\u0438\u0445\u0441\u044f \u0432 \u043d\u043e\u043c\u0435\u0440\u0430\u0445. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u043e\u043c\u0435\u0440\u043e\u0432 \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e, \u0438 \u0438\u043c\u0435\u044e\u0442\u0441\u044f \u043d\u043e\u043c\u0435\u0440\u0430 \u0442\u0440\u0435\u0445 \u0442\u0438\u043f\u043e\u0432: \u043e\u0434\u043d\u043e\u043c\u0435\u0441\u0442\u043d\u044b\u0439, \u0434\u0432\u0443\u0445\u043c\u0435\u0441\u0442\u043d\u044b\u0439 \u0438 \u0442\u0440\u0435\u0445\u043c\u0435\u0441\u0442\u043d\u044b\u0439, \u043e\u0442\u043b\u0438\u0447\u0430\u044e\u0449\u0438\u0435\u0441\u044f \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c\u044e \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u0432 \u0441\u0443\u0442\u043a\u0438. \u0412 \u043a\u0430\u0436\u0434\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435 \u0435\u0441\u0442\u044c \u0442\u0435\u043b\u0435\u0444\u043e\u043d. \u2003\u041e \u043a\u0430\u0436\u0434\u043e\u043c \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u044e\u0449\u0435\u043c \u0434\u043e\u043b\u0436\u043d\u0430 \u0445\u0440\u0430\u043d\u0438\u0442\u044c\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f: \u043d\u043e\u043c\u0435\u0440 \u043f\u0430\u0441\u043f\u043e\u0440\u0442\u0430, \u0444\u0430\u043c\u0438\u043b\u0438\u044f, \u0438\u043c\u044f, \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u043e, \u0433\u043e\u0440\u043e\u0434, \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043e\u043d \u043f\u0440\u0438\u0431\u044b\u043b, \u0434\u0430\u0442\u0430 \u043f\u043e\u0441\u0435\u043b\u0435\u043d\u0438\u044f \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435, \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0447\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440. \u2003\u041e \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u0438\u0437\u0432\u0435\u0441\u0442\u043d\u0430 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f: \u0444\u0430\u043c\u0438\u043b\u0438\u044f, \u0438\u043c\u044f, \u043e\u0442\u0447\u0435\u0441\u0442\u0432\u043e, \u0433\u0434\u0435 (\u044d\u0442\u0430\u0436) \u0438 \u043a\u043e\u0433\u0434\u0430 (\u0434\u0435\u043d\u044c \u043d\u0435\u0434\u0435\u043b\u0438) \u043e\u043d \u0443\u0431\u0438\u0440\u0430\u0435\u0442. \u0421\u043b\u0443\u0436\u0430\u0449\u0438\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0443\u0431\u0438\u0440\u0430\u0435\u0442 \u0432\u0441\u0435 \u043d\u043e\u043c\u0435\u0440\u0430 \u043d\u0430 \u043e\u0434\u043d\u043e\u043c \u044d\u0442\u0430\u0436\u0435 \u0432 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0435 \u0434\u043d\u0438 \u043d\u0435\u0434\u0435\u043b\u0438, \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u0432 \u0440\u0430\u0437\u043d\u044b\u0435 \u0434\u043d\u0438 \u043e\u043d \u043c\u043e\u0436\u0435\u0442 \u0443\u0431\u0438\u0440\u0430\u0442\u044c \u0440\u0430\u0437\u043d\u044b\u0435 \u044d\u0442\u0430\u0436\u0438. \u2003\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438: \u043e \u043a\u043b\u0438\u0435\u043d\u0442\u0430\u0445, \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u0432\u0448\u0438\u0445 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435, \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432\u0440\u0435\u043c\u0435\u043d\u0438; \u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432, \u043f\u0440\u0438\u0431\u044b\u0432\u0448\u0438\u0445 \u0438\u0437 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0433\u043e\u0440\u043e\u0434\u0430, \u043e \u0442\u043e\u043c, \u043a\u0442\u043e \u0438\u0437 \u0441\u043b\u0443\u0436\u0430\u0449\u0438\u0445 \u0443\u0431\u0438\u0440\u0430\u043b \u043d\u043e\u043c\u0435\u0440 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0433\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u0430 \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u0434\u0435\u043d\u044c \u043d\u0435\u0434\u0435\u043b\u0438, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435 \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0445 \u043d\u043e\u043c\u0435\u0440\u043e\u0432; \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 \u0441 \u0443\u043a\u0430\u0437\u0430\u043d\u0438\u0435\u043c \u043c\u0435\u0441\u0442\u0430 \u0436\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0440\u043e\u0436\u0438\u0432\u0430\u043b\u0438 \u0432 \u0442\u0435 \u0436\u0435 \u0434\u043d\u0438, \u0447\u0442\u043e \u0438 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u043a\u043b\u0438\u0435\u043d\u0442, \u0432 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u2003\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u0434\u043e\u043b\u0436\u0435\u043d \u0438\u043c\u0435\u0442\u044c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u043d\u0430 \u0440\u0430\u0431\u043e\u0442\u0443 \u0438\u043b\u0438 \u0443\u0432\u043e\u043b\u0438\u0442\u044c \u0441\u043b\u0443\u0436\u0430\u0449\u0435\u0433\u043e \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b; \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043b\u0443\u0436\u0430\u0449\u0435\u0433\u043e; \u043f\u043e\u0441\u0435\u043b\u0438\u0442\u044c \u0438\u043b\u0438 \u0432\u044b\u0441\u0435\u043b\u0438\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u2003\u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0440\u0435\u0434\u0443\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0442\u0430\u043a\u0436\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0432\u044b\u0434\u0430\u0447\u0438 \u043e\u0442\u0447\u0435\u0442\u0430 \u043e \u0440\u0430\u0431\u043e\u0442\u0435 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u044b \u0437\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u043a\u0432\u0430\u0440\u0442\u0430\u043b \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0433\u043e\u0434\u0430. \u0422\u0430\u043a\u043e\u0439 \u043e\u0442\u0447\u0435\u0442 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f: \u0447\u0438\u0441\u043b\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u043e\u0432 \u0437\u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u043f\u0435\u0440\u0438\u043e\u0434 \u0432 \u043a\u0430\u0436\u0434\u043e\u043c \u043d\u043e\u043c\u0435\u0440\u0435; \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u043e\u043c\u0435\u0440\u043e\u0432 \u043d\u0435 \u043a\u0430\u0436\u0434\u043e\u043c \u044d\u0442\u0430\u0436\u0435; \u043e\u0431\u0449\u0430\u044f \u0441\u0443\u043c\u043c\u0430 \u0434\u043e\u0445\u043e\u0434\u0430 \u0437\u0430 \u043a\u0430\u0436\u0434\u044b\u0439 \u043d\u043e\u043c\u0435\u0440; \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u044b\u0439 \u0434\u043e\u0445\u043e\u0434 \u043f\u043e \u0432\u0441\u0435\u0439 \u0433\u043e\u0441\u0442\u0438\u043d\u0438\u0446\u0435.","title":"\u041e\u0442\u0435\u043b\u044c"},{"location":"labs/3.1_Practice/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 3.1"},{"location":"labs/3.1_Practice/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/3.1_Practice/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/3.1_Practice/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/3.1_Practice/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/3.1_Practice/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/3.1_Practice/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"labs/Leetcode/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"Leetcode \u0437\u0430\u0434\u0430\u0447\u0438"},{"location":"labs/Leetcode/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/Leetcode/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/Leetcode/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/Leetcode/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/Leetcode/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/Leetcode/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"labs/lab_1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 1"},{"location":"labs/lab_1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/lab_1/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/lab_1/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/lab_1/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/lab_1/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/lab_1/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"labs/lab_2/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 2"},{"location":"labs/lab_2/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/lab_2/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/lab_2/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/lab_2/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/lab_2/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/lab_2/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"labs/lab_3/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 3"},{"location":"labs/lab_3/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/lab_3/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/lab_3/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/lab_3/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/lab_3/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/lab_3/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"},{"location":"labs/lab_4/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 2 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html> \u0417\u0430\u0434\u0430\u043d\u0438\u0435 4 \u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client() \u0417\u0430\u0434\u0430\u043d\u0438\u0435 5 \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 4"},{"location":"labs/lab_4/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"labs/lab_4/#1","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, server\u00bb, \u0438 \u043e\u043d\u043e \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \u0412 \u043e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u00abHello, client\u00bb, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043e\u0442\u043e\u0431\u0440\u0430\u0437\u0438\u0442\u044c\u0441\u044f \u0443 \u043a\u043b\u0438\u0435\u043d\u0442\u0430. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket.bind(('', 8080)) max_user = 1 response = b\"Hello, client\" while True: client_data, addr = socket.recvfrom(1024) if not client_data: break print(client_data) socket.sendto(response, addr) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: message = bytes(input(), 'utf-8') socket.sendto(message, ('localhost', 8080)) response = socket.recv(1024) if not response: break print(response) socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"labs/lab_4/#2","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u0443\u044e \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b. \u0421\u0435\u0440\u0432\u0435\u0440 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043a\u043b\u0438\u0435\u043d\u0442\u0443. \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438: \u041f\u043e\u0438\u0441\u043a \u043f\u043b\u043e\u0449\u0430\u0434\u0438 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import math server_socket = socket.socket() server_socket.bind(('', 8080)) max_user = 5 server_socket.listen(max_user) while True: client_socket, addr = server_socket.accept() client_data = list(map(lambda x: int(x), client_socket.recv(1024).decode().split())) if not client_data or len(client_data) != 3: print(\"Invalid parameters for triangle area task\") client_socket.close() break S = client_data[0] * client_data[1] * math.sin(client_data[2]) client_socket.send(bytes(str(S), 'utf-8')) print(client_data) socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket client_socket = socket.socket() client_socket.connect(('localhost', 8080)) print(\"Please write the lengths of 2 sides and an angle of the parallelogramm:\") client_socket.send(bytes(input(), 'utf-8')) res = client_socket.recv(1024) print(f\"Area = {res.decode()}\") client_socket.close()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2"},{"location":"labs/lab_4/#3","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0441\u0435\u0440\u0432\u0435\u0440\u043d\u0443\u044e \u0447\u0430\u0441\u0442\u044c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. \u041a\u043b\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0443, \u0438 \u0432 \u043e\u0442\u0432\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 HTTP-\u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0441\u0435\u0440\u0432\u0435\u0440 \u043f\u043e\u0434\u0433\u0440\u0443\u0436\u0430\u0435\u0442 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 index.html. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) socket.bind(('', 8080)) max_conn_count = 5 socket.listen(max_conn_count) while True: conn_socket, addr = socket.accept() request = conn_socket.recv(1024).decode().split() if request[0] != \"GET\": conn_socket.close() print(\"Bad Gateway\") conn_socket.send(b'Response 400') conn_socket.close() break print(request) with open('index.html', 'r') as index: response = 'Response 200' print(\"OK\") conn_socket.send(response.encode('utf-8')) conn_socket.close() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import http.client host = 'localhost' client_conn = http.client.HTTPConnection(host, 8080) client_conn.request('GET', 'index.html') response = client_conn.getresponse() print(response.read().decode()) \u041a\u043e\u0434 HTML-\u0440\u0430\u0437\u043c\u0435\u0442\u043a\u0438 <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>WEB Lab1-3</title> </head> <body> <h1> Hello, it's html page, delivered from python socket server. </h1> </body> </html>","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3"},{"location":"labs/lab_4/#4","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u0434\u0432\u0443\u0445\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0438\u043b\u0438 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0414\u043b\u044f \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0431\u0430\u043b\u043b\u043e\u0432 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0439\u0442\u0435 \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0447\u0430\u0442. \u0422\u0440\u0435\u0431\u043e\u0432\u0430\u043d\u0438\u044f: \u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 socket. \u0414\u043b\u044f \u043c\u043d\u043e\u0433\u043e\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0447\u0430\u0442\u0430 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0443 threading. \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import threading from copy import copy max_conn_count = 10 locker = threading.Lock() threads = [] connections = [] def threaded_handle(conn, address): while True: data = conn.recv(1024) if not data: conn.close() print(f\"{address} connection interrupted\") break msg = address[0] + \":\" + str(address[1]) + \" send a message: \" + data.decode() print(msg) with locker: conn_copy = copy(connections) for c in conn_copy: c.sendall(msg.encode('utf-8')) def main(): a_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) a_socket.bind(('', 8080)) a_socket.listen(max_conn_count) while True: conn_socket, addr = a_socket.accept() conn_thread = threading.Thread(target=threaded_handle, args=(conn_socket, addr,)) threads.append(conn_thread) connections.append(conn_socket) conn_thread.start() if __name__ == \"__main__\": main() \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import socket import threading getting_msg, host, port = True, 'localhost', 8080 client_locker = threading.Lock() def show_chat(sock): while True: with client_locker: serv_data = sock.recv(1024) if not serv_data: with client_locker: sock.close() print(\"Connection closed\") break print(serv_data.decode()) def main_client(): client_socket = socket.socket() client_socket.connect((host, port)) chat_thread = threading.Thread(target=show_chat, args=(client_socket,)) chat_thread.start() while getting_msg: new_msg = input().encode('utf-8') client_socket.send(new_msg) chat_thread.join() if __name__ == \"__main__\": main_client()","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4"},{"location":"labs/lab_4/#5","text":"\u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0432\u0435\u0431-\u0441\u0435\u0440\u0432\u0435\u0440 \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 GET \u0438 POST HTTP-\u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 socket \u0432 Python. \u0421\u0435\u0440\u0432\u0435\u0440 \u0434\u043e\u043b\u0436\u0435\u043d: \u041f\u0440\u0438\u043d\u044f\u0442\u044c \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435 \u0438 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0435. \u041e\u0442\u0434\u0430\u0442\u044c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e\u0431\u043e \u0432\u0441\u0435\u0445 \u043e\u0446\u0435\u043d\u043a\u0430\u0445 \u043f\u043e \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u0430\u043c \u0432 \u0432\u0438\u0434\u0435 HTML-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b. Web-\u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0441 \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0442\u0430\u043a: \u041a\u043e\u0434 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: import socket import json from bs4 import BeautifulSoup as bs from urllib.parse import urlparse, parse_qs from datetime import datetime max_headers = 100 class HTTPRequest: def __init__(self, method, url, version, headers, r_body): self.method = method self.url = url self.version = version self.headers = headers self.body = r_body @property def parsed_url(self): return urlparse(self.url) @property def query(self): return parse_qs(self.parsed_url.query) class HTTPResponse: def __init__(self, code, status, version, headers=None, body=None): self.code = code self.status = status self.version = version self.headers = headers self.body = body def compile(self): resp = f\"{self.version} {self.code} {self.status}\\n\" if self.headers: for header, value in self.headers.items(): resp += f\"{header}: {value}\\n\" if self.body: resp += f\"\\n{self.body}\" return resp def compile_html(req, filename, json_file): soup = bs(open(filename, 'r+'), \"html.parser\") caption = soup.find('h2', {'id': 'subj_name'}) mark_list = soup.find('ul', {'id': 'marks'}) try: subj = req.query['subject'][0] caption.string = f\"\u041e\u0446\u0435\u043d\u043a\u0438 \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443: {subj}\" with open(json_file, 'r') as grades_file: subjects = json.load(grades_file) marks = subjects[subj] for mark in marks: mark_li = soup.new_tag('li') mark_li.string = mark mark_list.append(mark_li) return soup.prettify('utf-8').decode() except KeyError: raise Exception(\"Wrong request parameters\") class HTTPServer: def __init__(self, ip, port): self.ip = ip self.port = port self.name = \"MyHTTPServer\" self.http_v = \"HTTP/1.1\" def serve_forever(self): serv_sock = socket.socket() serv_sock.bind((self.ip, self.port)) serv_sock.listen() try: while True: conn_socket, addr = serv_sock.accept() self.serve_client(conn_socket) finally: serv_sock.close() def serve_client(self, connection): req = self.parse_request(connection) if req: resp = self.handle_request(req).compile() resp_encoded = resp.encode() connection.sendall(resp_encoded) connection.close() def parse_request(self, connection): with connection.makefile('rb') as req_file: raw_first_line = req_file.readline() first_line = str(raw_first_line, 'utf-8') method, url, version = first_line.split() headers = self.parse_headers(req_file) return HTTPRequest(method, url, version, headers, req_file) def parse_headers(self, rfile): headers = dict() while len(headers) <= max_headers: r_line = rfile.readline().decode('utf-8') if r_line == '\\n' or r_line == '' or r_line == '\\r\\n': return headers header, value = tuple(r_line.split()) headers[header] = value raise Exception('too many headers') def handle_request(self, req): if req.parsed_url.path == \"/grades\": if req.method == \"GET\": html = compile_html(req, \"html/index.html\", \"json/grades.json\") resp_headers = { \"Server\": self.name, \"Date\": str(datetime.now()), \"Content-Length\": len(html), \"Content-Type\": \"text/html; charset=utf-8\" } return HTTPResponse(200, \"OK\", self.http_v, resp_headers, html) elif req.method == \"POST\": with open(\"json/grades.json\", \"r+\") as grades_file: subjects = json.load(grades_file) try: subjects[req.query[\"subject\"][0]].append(req.query[\"mark\"][0]) except KeyError: raise Exception(\"Wrong request parameters\") grades_file.seek(0) json.dump(subjects, grades_file) grades_file.truncate() return HTTPResponse(204, \"Created\", self.http_v) else: return HTTPResponse(400, \"Bad Request\", self.http_v) if __name__ == '__main__': host = '127.0.0.1' _port = 8080 serv = HTTPServer(host, _port) try: serv.serve_forever() except KeyboardInterrupt: pass \u041a\u043e\u0434 \u043a\u043b\u0438\u0435\u043d\u0442\u0430: import os import http.client import webbrowser class HTTPClient: def __init__(self): self.conn = None def connect_to(self, ip, port): self.conn = http.client.HTTPConnection(ip, port) def post_mark(self, subj, grade): if not self.conn: raise Exception('No connection provided') self.conn.request('POST', f\"/grades?subject={subj}&mark={grade}\") serv_response = self.conn.getresponse() print(serv_response.status, serv_response.reason) def get_marks(self, subj): if not self.conn: raise Exception('No connection provided') self.conn.request('GET', f\"/grades?subject={subj}\") serv_response = self.conn.getresponse() path = \"html/client.html\" body = serv_response.read() with open(path, \"wb\") as cli_html: cli_html.write(body) webbrowser.open('file://' + os.path.realpath(path), new=2) if __name__ == \"__main__\": _ip, _port = '127.0.0.1', 8080 client = HTTPClient() while True: client.connect_to(_ip, _port) subject = input(\"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043f\u0440\u0435\u0434\u043c\u0435\u0442: \") choice = int(input(\"1 - \u0412\u044b\u0441\u0442\u0430\u0432\u0438\u0442\u044c(POST) \u043e\u0446\u0435\u043d\u043a\u0443\\n2 - \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c(GET) \u043e\u0446\u0435\u043d\u043a\u0438\\n\")) if choice == 1: mark = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0446\u0435\u043d\u043a\u0443 \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b): \")) if mark < 2 or mark > 5: raise Exception('\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043e\u0442 2(\u043d\u0435\u0443\u0434) \u0434\u043e 5(\u043e\u0442\u043b)') client.post_mark(subject, mark) continue client.get_marks(subject) JSON c \u043e\u0446\u0435\u043d\u043a\u0430\u043c\u0438 { \"Math\": [\"4\", \"4\", \"5\", \"4\", \"4\", \"2\", \"5\", \"2\"], \"Geography\": [\"3\", \"4\"], \"Informatics\": [\"2\", \"5\"], \"Chemistry\": [\"2\", \"4\"], \"History\": [\"5\", \"4\", \"4\", \"2\"], \"English\": [\"4\", \"4\", \"2\", \"4\", \"2\"], \"PE\": [\"2\", \"5\"], \"Physics\": [\"5\", \"4\"] }","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5"}]}